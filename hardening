#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long qw(GetOptions);
use File::Basename qw(dirname basename);
use File::Copy qw(copy);
use File::Path qw(make_path);
use File::Find;
use Digest::SHA qw(sha256_hex);
use Cwd qw(abs_path);

# -----------------------------
# Configurable defaults
# -----------------------------
my $REPO_ROOT = dirname(abs_path($0));      # directory where the script lives
my $FILES_DIR = "$REPO_ROOT/files";

# system install locations
my %SYSTEM_DIR = (
    'fail2ban_filter' => '/etc/fail2ban/filter.d',
    'fail2ban_jaild' => '/etc/fail2ban/jail.d',
    'httpd_confd'   => '/etc/httpd/conf.d',
    'sbin'      => '/usr/sbin',
    );

# health monitor (cron) settings
my $CRON_FILE = '/etc/cron.d/httpd_protection_health';
my $CRON_EVERY_MINUTES = '*/5'; # adjust if desired
my $HEALTH_SRC_BASENAME = 'apache-health';   # repo file name
my $HEALTH_INSTALLED  = 'apache-health';   # installed file name

# -----------------------------
# Globals for CLI
# -----------------------------
my ($opt_help, $opt_install, $opt_health, $opt_status, $opt_update_repo, $opt_update_system);
GetOptions(
    'help'             => \$opt_help,
    'install'          => \$opt_install,
    'health-monitor=s' => \$opt_health,   # on|off
    'status'           => \$opt_status,
    'update-repo'      => \$opt_update_repo, # copy system -> repo for modified files
    'update-system'    => \$opt_update_system, # copy repo -> system for modified files
    ) or die usage();

# Default action
if (!(defined $opt_help || defined $opt_install || defined $opt_health || defined $opt_status || defined $opt_update_repo || defined $opt_update_system)) {
    print usage();
    exit 0;
}

# Ensure root for system-changing operations
if ($opt_install || $opt_update_system || defined $opt_health) {
    if ($> != 0) {
        die "[ERROR] This action requires root. Re-run with sudo or as root.\n";
    }
}

# Build mapping repo->system
my @pairs = compute_pairs();

if ($opt_help) {
    print usage();
    exit 0;
}
elsif ($opt_install) {
    ensure_fail2ban();
    do_install(\@pairs);
}
elsif (defined $opt_health) {
    do_health_monitor(\@pairs, $opt_health);
}
elsif ($opt_status) {
    do_status(\@pairs);
    # The new lines have been added below:
    print "\n--- health monitor status ---\n";
    show_health_monitor_status();
    # End of new additions

    print "\n--- fail2ban status ---\n";
    show_fail2ban_status();
}
elsif ($opt_update_repo) {
    do_update_repo(\@pairs);
}
elsif ($opt_update_system) {
    do_update_system(\@pairs);
}
exit 0;

# -----------------------------
# Functions
# -----------------------------

sub usage {
    return <<'USAGE';
hardening --help
hardening --install
hardening --health-monitor on|off
hardening --status
hardening --update-repo
hardening --update-system

Options:
 --help            Show this message (also the default if run with no args).
 --install         Install all components from ./files into system paths.
                   Will NOT clobber existing files; checks all targets first,
                   and aborts with a clear message listing what to remove.
                   Also ensures fail2ban is installed and its service enabled.
 --health-monitor on|off
                   Enable or disable the apache health-check cron job.
                   Dies with a message if the tool is not installed.
 --status          Dies if not installed. Shows diffs between installed
                   system files and repo files (by checksum). Also prints
                   a concise fail2ban service status summary.
 --update-repo     Copy modified installed files back into the repo, printing actions.
 --update-system   Copy modified repo files into the system, printing actions.
                   Makes timestamped backups before overwriting.

Assumptions:
 - Run this script from anywhere; it uses its own location as the repo root.
 - Repo files live under ./files relative to the script:
    files/fail2ban/filter.d/*.conf -> /etc/fail2ban/filter.d/
    files/fail2ban/jail.d/99-hardening.local -> /etc/fail2ban/jail.d/
    files/httpd/conf.d/hardening.conf -> /etc/httpd/conf.d/
    files/sbin/apache-health -> /usr/sbin/apache-health
    files/sbin/list_bans -> /usr/sbin/list_bans
USAGE
}

sub compute_pairs {
    my @pairs;

    # fail2ban filters
    my $repo_f2b_filters = "$FILES_DIR/fail2ban/filter.d";
    if (-d $repo_f2b_filters) {
        opendir(my $dh, $repo_f2b_filters) or die "Cannot open $repo_f2b_filters: $!";
        while (my $f = readdir($dh)) {
            next unless $f =~ /\.conf$/;
            push @pairs, {
                src => "$repo_f2b_filters/$f",
                dst => "$SYSTEM_DIR{fail2ban_filter}/$f",
                mode => 0644,
            };
        }
        closedir($dh);
    }

    # fail2ban jail.d
    my $repo_f2b_jaild = "$FILES_DIR/fail2ban/jail.d";
    if (-d $repo_f2b_jaild) {
        opendir(my $jh, $repo_f2b_jaild) or die "Cannot open $repo_f2b_jaild: $!";
        while (my $f = readdir($jh)) {
            next unless $f =~ /\.local$/;
            push @pairs, {
                src => "$repo_f2b_jaild/$f",
                dst => "$SYSTEM_DIR{fail2ban_jaild}/$f",
                mode => 0644,
            };
        }
        closedir($jh);
    }

    # httpd conf.d
    my $repo_httpd_confd = "$FILES_DIR/httpd/conf.d";
    if (-d $repo_httpd_confd) {
        opendir(my $hh, $repo_httpd_confd) or die "Cannot open $repo_httpd_confd: $!";
        while (my $f = readdir($hh)) {
            next unless $f =~ /\.conf$/;
            push @pairs, {
                src => "$repo_httpd_confd/$f",
                dst => "$SYSTEM_DIR{httpd_confd}/$f",
                mode => 0644,
            };
        }
        closedir($hh);
    }

    # sbin scripts
    my $repo_sbin = "$FILES_DIR/sbin";
    if (-d $repo_sbin) {
        opendir(my $sh, $repo_sbin) or die "Cannot open $repo_sbin: $!";
        while (my $f = readdir($sh)) {
            next if $f =~ /^\./;
            my ($src, $dst, $mode);
            if ($f eq $HEALTH_SRC_BASENAME) {
                $src = "$repo_sbin/$f";
                $dst = "$SYSTEM_DIR{sbin}/$HEALTH_INSTALLED";
                $mode = 0755;
            } else {
                $src = "$repo_sbin/$f";
                $dst = "$SYSTEM_DIR{sbin}/$f";
                $mode = 0755 if -x $src;
                $mode //= 0755; # default executable for sbin
            }
            push @pairs, { src => $src, dst => $dst, mode => $mode };
        }
        closedir($sh);
    }

    return @pairs;
}

sub require_installed_or_die {
    my ($pairs_ref) = @_;
    my @missing;
    for my $p (@$pairs_ref) {
        push @missing, $p->{dst} unless -e $p->{dst};
    }
    if (@missing) {
        die "[ERROR] Not installed. Missing files:\n " . join("\n ", @missing) . "\nPlease run: hardening --install\n";
    }
}

sub do_install {
    my ($pairs_ref) = @_;

    my @existing;
    for my $p (@$pairs_ref) {
        push @existing, $p->{dst} if -e $p->{dst};
    }
    if (@existing) {
        die "[ERROR] Install would clobber existing files. Remove these first:\n " . join("\n ", @existing) . "\n";
    }

    # Ensure destination directories exist first
    my %dirs;
    for my $p (@$pairs_ref) {
        my $d = dirname($p->{dst});
        $dirs{$d} = 1;
    }
    for my $d (sort keys %dirs) {
        unless (-d $d) {
            make_path($d) or die "Failed to create directory $d: $!";
            print "[OK] Created directory: $d\n";
        }
    }

    # Copy files
    for my $p (@$pairs_ref) {
        copy_or_die($p->{src}, $p->{dst});
        chmod $p->{mode}, $p->{dst} or die "chmod $p->{mode} $p->{dst} failed: $!";
        print "[OK] Installed: $p->{dst}\n";
    }

    print "\n[NOTE] Installation complete. Consider enabling the health monitor with:\n hardening --health-monitor on\n";
    print "[NOTE] You may want to (re)start fail2ban to pick up new jails/filters:\n systemctl restart fail2ban\n";
}

sub do_health_monitor {
    my ($pairs_ref, $state) = @_;
    $state = lc($state // '');
    die "Usage: hardening --health-monitor on|off\n" unless $state eq 'on' || $state eq 'off';

    # must be installed
    require_installed_or_die($pairs_ref);

    if ($state eq 'on') {
        my $health_path = "$SYSTEM_DIR{sbin}/$HEALTH_INSTALLED";
        unless (-x $health_path) {
            die "[ERROR] Health script not found at $health_path. Reinstall or fix install.\n";
        }
        my $cron = <<"CRON";
# Managed by httpd_protection 'hardening' tool
SHELL=/bin/bash
PATH=/usr/sbin:/usr/local/bin:/usr/bin:/sbin:/bin

$CRON_EVERY_MINUTES * * * * root $health_path --quiet || true
CRON
        write_text($CRON_FILE, $cron, 0644);
        print "[OK] Health monitor enabled via $CRON_FILE\n";
        print "[HINT] You can verify with: systemctl status crond (or cron)\n";
    } else {
        if (-e $CRON_FILE) {
            unlink $CRON_FILE or die "Failed to remove $CRON_FILE: $!";
            print "[OK] Health monitor disabled (removed $CRON_FILE)\n";
        } else {
            print "[OK] Health monitor already disabled (no $CRON_FILE)\n";
        }
    }
}

sub show_health_monitor_status {
    my $status = (-e $CRON_FILE) ? 'ON' : 'OFF';
    my $file_status = (-e $CRON_FILE) ? "File exists at $CRON_FILE" : "File missing: $CRON_FILE";
    print "status: **$status**\n";
    print "file: $file_status\n";

    if ($status eq 'ON') {
        # Optionally show the cron job content for verification
        # You may want to add a utility function like 'read_text' if you don't have 'slurp' defined
        # Since 'slurp' exists, let's use it carefully:
        if (-r $CRON_FILE) {
            my $content = slurp($CRON_FILE);
            my @lines = split /\n/, $content;
            my $job_line = grep { /^\s*\*\/\d+\s+\*\s+\*\s+\*\s+\*\s+root/ } @lines;
            if ($job_line) {
                print "job: Found cron entry (runs every $CRON_EVERY_MINUTES minutes)\n";
            } else {
                print "job: [WARN] Cron file exists but main job line not found.\n";
            }
        }
    }
}
# End of new subroutine

sub do_status {
    my ($pairs_ref) = @_;
    require_installed_or_die($pairs_ref);

    my $differences = 0;
    for my $p (@$pairs_ref) {
        my $src = $p->{src};
        my $dst = $p->{dst};
        if (!-e $src) {
            print "[WARN] Repo file missing: $src (cannot compare)\n";
            next;
        }
        if (files_differ($src, $dst)) {
            $differences++;
            print "[DIFF] $dst differs from repo $src\n";
        }
    }
    if ($differences == 0) {
        print "[OK] All installed files match the repo versions.\n";
    } else {
        print "[INFO] $differences file(s) differ. Use --update-repo or --update-system to reconcile.\n";
    }
}

sub do_update_repo {
    my ($pairs_ref) = @_;
    require_installed_or_die($pairs_ref);
    my $changes = 0;
    for my $p (@$pairs_ref) {
        my ($src, $dst) = ($p->{src}, $p->{dst});
        if (!-e $dst) {
            print "[SKIP] Not installed (missing): $dst\n";
            next;
        }
        if (!-e $src || files_differ($src, $dst)) {
            # Ensure repo dir exists
            my $src_dir = dirname($src);
            unless (-d $src_dir) {
                make_path($src_dir) or die "Failed to create repo dir $src_dir: $!";
                print "[OK] Created repo dir: $src_dir\n";
            }
            copy_or_die($dst, $src);
            print "[PULL] Copied system -> repo: $dst -> $src\n";
            $changes++;
        } else {
            print "[OK] No change: $dst matches repo.\n";
        }
    }
    print "[DONE] Updated repo with $changes change(s).\n";
}


sub do_update_system {
    my ($pairs_ref) = @_;
    my $timestamp = ts();
    my $changes = 0;
    my $updated_httpd_conf = 0;
    my $updated_fail2ban  = 0;

    for my $p (@$pairs_ref) {
        my ($src, $dst, $mode) = ($p->{src}, $p->{dst}, $p->{mode});

        unless (-e $src) {
            print "[SKIP] Repo missing: $src
";
            continue;
        }

        my $needs_update = (!-e $dst || files_differ($src, $dst)) ? 1 : 0;

        if ($needs_update) {
            # ensure dir
            my $dst_dir = dirname($dst);
            unless (-d $dst_dir) {
                make_path($dst_dir) or die "Failed to create $dst_dir: $!";
                print "[OK] Created directory: $dst_dir
";
            }
            # backup existing
            if (-e $dst) {
                my $bak = "$dst.bak-$timestamp";
                copy_or_die($dst, $bak);
                print "[BACKUP] $dst -> $bak
";
            }
            copy_or_die($src, $dst);
            chmod $mode, $dst or die "chmod $mode $dst failed: $!";
            print "[PUSH] Copied repo -> system: $src -> $dst
";
            $changes++;

            # Track what changed
            $updated_httpd_conf = 1 if $dst eq "$SYSTEM_DIR{httpd_confd}/hardening.conf";
            if ($dst =~ m{^/etc/fail2ban/(filter\.d|jail\.d)/} ) {
                $updated_fail2ban = 1;
            }
        } else {
            print "[OK] No change: $dst already matches repo.
";
        }
    }

    print "[DONE] Updated system with $changes change(s).
";

    # Post-actions
    if ($updated_fail2ban) {
        if (has_cmd('systemctl')) {
            my ($out, $rc) = run_capture('systemctl restart fail2ban');
            if ($rc == 0) {
                print "[OK] Restarted fail2ban to apply updated jails/filters.
";
            } else {
                print "[WARN] Failed to restart fail2ban. Please run manually:
";
                print "systemctl restart fail2ban
";
            }
        } else {
            print "[INFO] To apply fail2ban changes, run:
";
            print "service fail2ban restart
";
        }
    }

    if ($updated_httpd_conf) {
        print "[NOTE] httpd hardening.conf was updated. Reload httpd to apply changes. Run:
";
        print "systemctl reload httpd || systemctl restart httpd
";
    }

    print "[NOTE] You may want to reload/restart services if configs changed, e.g.:
 systemctl reload httpd || systemctl restart httpd
 systemctl restart fail2ban
" unless ($updated_fail2ban || $updated_httpd_conf);
}

# -----------------------------
# fail2ban helpers
# -----------------------------

sub ensure_fail2ban {
    return if has_cmd('fail2ban-client');
    print "[INFO] fail2ban not found. Attempting to install...\n";

    my $pm = detect_pkg_manager();
    if (!$pm) {
        die "[ERROR] Could not detect a supported package manager (dnf, yum, apt-get). Please install fail2ban manually.\n";
    }

    my ($out, $rc);
    if ($pm eq 'dnf') {
        ($out, $rc) = run_capture('dnf -y install fail2ban');
    } elsif ($pm eq 'yum') {
        ($out, $rc) = run_capture('yum -y install fail2ban');
    } else { # apt-get
        ($out, $rc) = run_capture('apt-get update && apt-get -y install fail2ban');
    }
    if ($rc != 0) {
        die "[ERROR] Failed to install fail2ban using $pm.\n$out\n";
    }
    print "[OK] fail2ban installed via $pm.\n";

    if (has_cmd('systemctl')) {
        run_capture('systemctl enable fail2ban');
        run_capture('systemctl start fail2ban');
        print "[OK] fail2ban service enabled and started.\n";
    } else {
        print "[WARN] systemctl not found; please ensure fail2ban is started.\n";
    }
}

sub show_fail2ban_status {
    if (has_cmd('systemctl')) {
        my ($act_out, $act_rc) = run_capture('systemctl is-active fail2ban');
        chomp $act_out;
        my ($ena_out, $ena_rc) = run_capture('systemctl is-enabled fail2ban');
        chomp $ena_out if defined $ena_out;
        print "service: active=$act_out, enabled=$ena_out\n";
    } else {
        print "service: systemctl not available\n";
    }

    if (has_cmd('fail2ban-client')) {
        my ($ping, $prc) = run_capture('fail2ban-client ping');
        chomp $ping if defined $ping;
        print "client: $ping\n";
        my ($stat, $src) = run_capture('fail2ban-client status');
        if ($src == 0) {
            print $stat;
        } else {
            print "[WARN] fail2ban-client status failed.\n";
        }
    } else {
        print "client: fail2ban-client not found\n";
    }
}

sub has_cmd {
    my ($cmd) = @_;
    my ($out, $rc) = run_capture("command -v $cmd");
    return $rc == 0 && $out;
}

sub detect_pkg_manager {
    return 'dnf'   if has_cmd('dnf');
    return 'yum'   if has_cmd('yum');
    return 'apt-get' if has_cmd('apt-get');
    return undef;
}

sub run_capture {
    my ($cmd) = @_;
    my $out = qx{$cmd 2>&1};
    my $rc = $? >> 8;
    return ($out, $rc);
}

# -----------------------------
# Utilities
# -----------------------------

sub files_differ {
    my ($a, $b) = @_;
    return 1 unless (-e $a && -e $b && -f $a && -f $b);
    return sha256_hex(slurp($a)) ne sha256_hex(slurp($b));
}

sub copy_or_die {
    my ($src, $dst) = @_;
    die "Source not found: $src\n" unless -e $src;
    copy($src, $dst) or die "Copy failed: $src -> $dst : $!";
}

sub write_text {
    my ($path, $content, $mode) = @_;
    my $dir = dirname($path);
    unless (-d $dir) {
        make_path($dir) or die "Failed to create $dir: $!";
    }
    open my $fh, '>', $path or die "Open for write failed $path: $!";
    print {$fh} $content;
    close $fh or die "Close failed $path: $!";
    chmod $mode, $path or die "chmod $mode $path failed: $!";
}

sub slurp {
    my ($path) = @_;
    open my $fh, '<', $path or die "Open failed $path: $!";
    binmode($fh);
    local $/;
    my $data = <$fh>;
    close $fh;
    return $data;
}

sub ts {
    my @t = localtime();
    return sprintf('%04d%02d%02d-%02d%02d%02d', $t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0]);
}
